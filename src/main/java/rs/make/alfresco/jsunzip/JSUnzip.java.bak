package rs.make.alfresco.jsunzip;

import java.io.BufferedInputStream;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.InputStream;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;

import javax.activation.MimetypesFileTypeMap;

import org.alfresco.model.ContentModel;
import org.alfresco.repo.jscript.BaseScopableProcessorExtension;
import org.alfresco.repo.security.authentication.AuthenticationUtil;
import org.alfresco.repo.transaction.RetryingTransactionHelper;
import org.alfresco.repo.transaction.RetryingTransactionHelper.RetryingTransactionCallback;
import org.alfresco.service.ServiceRegistry;
import org.alfresco.service.cmr.repository.ContentReader;
import org.alfresco.service.cmr.repository.NodeRef;
import org.alfresco.service.cmr.repository.NodeService;
import org.alfresco.service.cmr.version.VersionService;
import org.alfresco.service.transaction.TransactionService;
import org.apache.log4j.Logger;

import rs.make.alfresco.alfcontent.AlfContent;

/**
 * @desc expose unzip functionality to Alf JS
 * 
 * @filename JSUnzip.java
 * @author Momcilo Dzunic (momcilo@dzunic.net)
 * @licence MIT
 */
public class JSUnzip extends BaseScopableProcessorExtension {
	protected ServiceRegistry serviceRegistry;
    public ServiceRegistry getServiceRegistry() {
        return serviceRegistry;
    }
    public void setServiceRegistry( ServiceRegistry serviceRegistry ) {
        this.serviceRegistry = serviceRegistry;
    }

    protected NodeService nodeService;
    public NodeService getNodeService() {
        return nodeService;
    }
    public void setNodeService( NodeService nodeService ) {
        this.nodeService = nodeService;
    }

    protected VersionService versionService;
    public VersionService getVersionService() {
        return versionService;
    }
    public void setVersionService( VersionService versionService ) {
        this.versionService = versionService;
    }

    protected TransactionService transactionService;
    public TransactionService getTransactionService() {
        return transactionService;
    }
    public void setTransactionService( TransactionService transactionService ) {
        this.transactionService = transactionService;
    }

    private static Logger logger = Logger.getLogger( JSUnzip.class );

    private AlfContent alfcontent = new AlfContent();

    private final String MIME_ZIP = "application/zip";
    private ThreadGroup tg = new ThreadGroup( "alfuzip" );
    private final int MAX_ACTIVE_THREADS = 64;
	private int sleeping = 0;
	private final int SLEEPING_DURATION = 1000;
	private final int MAX_SLEEPING_DURATION = 5000;

    InputStream is;
	BufferedInputStream bis;
	ZipInputStream zis;

	@SuppressWarnings("unused")
	public boolean fromNode( String sNodeRef , String sParentNodeRef ) throws Exception {
		boolean result = false;
		final NodeRef nodeRef = new NodeRef( sNodeRef );
		final NodeRef parentNodeRef = new NodeRef( sParentNodeRef );
		if( nodeRef == null ) {
			logger.error( "Invalid zip node ref provided " + sNodeRef );
			return false;
		}
		if( parentNodeRef == null ) {
			logger.error( "Invalid destination node ref provided " + sParentNodeRef );
			return false;
		}

		try{
			ContentReader contentReader = serviceRegistry.getContentService().getReader( nodeRef , ContentModel.PROP_CONTENT );
	        String mimetype = contentReader.getMimetype();
	        if( mimetype.equalsIgnoreCase( MIME_ZIP ) == false ){
				logger.error( "Invalid mimetype of source node: \"" + mimetype + "\". It should be \"" + MIME_ZIP + "\"." );
	        	return false;
	        }

	        is = contentReader.getContentInputStream();
			bis = new BufferedInputStream( is );
			zis = new ZipInputStream( bis );
	        unpackEntry( zis , parentNodeRef );

	        result = true;
		}
		catch( Exception e ){
			logger.error( e );
			e.printStackTrace();
		}

		return result;
    }

	private void unpackEntry( ZipInputStream zis , NodeRef parentNodeRef ) throws Exception
	{
		int activeThreadsNo = tg.activeCount();
		logger.error( "Active threads: " + activeThreadsNo );
		if( activeThreadsNo >= MAX_ACTIVE_THREADS ){
			System.gc();
/*			sleeping += SLEEPING_DURATION;
			if( sleeping < MAX_SLEEPING_DURATION ) {
				logger.error( "Sleeping for " + sleeping + "ms already..." );
				Thread.sleep( SLEEPING_DURATION );
				unpackEntry( zis , parentNodeRef );
			}
*/		}

		ZipEntry zipEntry = zis.getNextEntry();
		if( zipEntry != null ){
			String name = zipEntry.getName();
			String fmimetype = new MimetypesFileTypeMap().getContentType( zipEntry.getName() );

			/* 
			 * Easy solution would be to use BufferedInputStream( zis )
			 * however alf writer.putContent() will close all resources automatically
			 * and as so zis as well after first loop iteration
			 */
//			BufferedInputStream fzis = new BufferedInputStream( zis );
			/*
			 * WORKAROUND - cloning input stream for each ZipEntry 
			 */
			ByteArrayOutputStream baos = new ByteArrayOutputStream();
			byte[] buffer = new byte[1024];
			int len;
			while ( ( len = zis.read( buffer ) ) > -1 ) {
			    baos.write( buffer , 0 , len) ;
			}
			baos.flush();
			InputStream bzis = new ByteArrayInputStream( baos.toByteArray() );
			BufferedInputStream fzis = new BufferedInputStream( bzis );
			
        	DoWriteEntryInThread doWriteEntryInThread = new DoWriteEntryInThread( name , fmimetype , parentNodeRef , fzis , zis , serviceRegistry , nodeService , versionService , transactionService , tg );
            Thread t = new Thread( tg , doWriteEntryInThread );
            t.start();
            t.join();
            t.interrupt();

            baos.close();
			bzis.close();
			fzis.close();
		}
		else{
	        zis.close();
	        bis.close();
	        is.close();
		}
	}
	
	private NodeRef writeEntry( String name , String fmimetype , NodeRef parentNodeRef , BufferedInputStream fzis ) throws Exception
	{
		NodeRef zipEntryNodeRef = null;
    	String[] pathPieces = name.split( "/" );
		int i = 0;
		NodeRef floatingParentNodeRef = parentNodeRef;
		alfcontent.serviceRegistry = this.serviceRegistry;
		alfcontent.nodeService = this.nodeService;
		alfcontent.versionService = this.versionService;
		while( i < pathPieces.length - 1 ){
			floatingParentNodeRef = alfcontent.createFolderNode( floatingParentNodeRef , pathPieces[ i ] , null , null );
			logger.error( "Folder \"" + pathPieces[ i ] + "\" created, with nodeRef \"" + floatingParentNodeRef + "\"..." );
			i++;
		}
		String fileName = pathPieces[ pathPieces.length - 1 ];
		if( fileName.equals( "" ) == false ){
			zipEntryNodeRef = alfcontent.createContentNode( floatingParentNodeRef , fileName , fzis , null , fmimetype , null , null );
			logger.error( "Content \"" + fileName + "\" created, with nodeRef \"" + zipEntryNodeRef + "\"..." );
		}
		return zipEntryNodeRef;
	}


	class DoWriteEntryInThread implements Runnable {
	    private String name;
	    private String fmimetype;
		private NodeRef parentNodeRef;
		private BufferedInputStream fzis;
		private ZipInputStream zis;
		private ServiceRegistry serviceRegistry;
		private NodeService nodeService;
		private VersionService versionService;
		private TransactionService transactionService;
		private ThreadGroup tg;
		static final int MAX_TRANSACTION_RETRIES = 1;
		
		DoWriteEntryInThread( String name , String fmimetype , NodeRef parentNodeRef , BufferedInputStream fzis , ZipInputStream zis , ServiceRegistry serviceRegistry , NodeService nodeService , VersionService versionService , TransactionService transactionService , ThreadGroup tg ) {
	        this.name = name;
	        this.fmimetype = fmimetype;
	        this.parentNodeRef = parentNodeRef;
	        this.fzis = fzis;
	        this.zis = zis;
	        this.nodeService = nodeService;
	        this.serviceRegistry = serviceRegistry;
	        this.versionService = versionService;
	        this.transactionService = transactionService;
	        this.tg = tg;
	    }
		@Override
	    public void run() {
			AuthenticationUtil.setAdminUserAsFullyAuthenticatedUser();
			final JSUnzip jsunzip = new JSUnzip();
			jsunzip.serviceRegistry = serviceRegistry;
			jsunzip.nodeService = nodeService;
			jsunzip.versionService = versionService;
			jsunzip.transactionService = transactionService;
			jsunzip.sleeping = 0;
			jsunzip.tg = tg;
	   		RetryingTransactionCallback<NodeRef> callback = new RetryingTransactionCallback<NodeRef>() {
	   			@Override
	   			public NodeRef execute() throws Throwable {
	   				NodeRef zipEntryNodeRef = jsunzip.writeEntry( name , fmimetype , parentNodeRef , fzis );
	   				return zipEntryNodeRef;
	   			}
	    	};
	    	// run transaction
			try {
				RetryingTransactionHelper txnHelper = transactionService.getRetryingTransactionHelper();
				txnHelper.setMaxRetries( MAX_TRANSACTION_RETRIES );
				NodeRef zipEntryNodeRef = txnHelper.doInTransaction( callback , false , true );
				if( zipEntryNodeRef == null )
						JSUnzip.logger.error( "\"" + name + "\" is NOT created." );
				JSUnzip.logger.error( "Looking for next entry in zip input stream..." );
				Thread.yield();
				jsunzip.unpackEntry( zis , parentNodeRef );
			}
			catch ( Throwable e ) {
				JSUnzip.logger.error( e );
				e.printStackTrace();
				try {
					JSUnzip.logger.error( "Previous entry ended up with error, so trying to continue with next entry... Looking for next entry in zip input stream..." );
					Thread.yield();
					jsunzip.unpackEntry( zis , parentNodeRef );
				}
				catch ( Exception e1 ) {
					JSUnzip.logger.error( e1 );
					e1.printStackTrace();
				}
			}
	    }
	}

}
